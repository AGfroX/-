# 基本数据类型

string、hash、list、set、zset



##  string与hash的数据差别

在网路传输时候，必须要进行进行序列化，才可以进行网路传输，那么在使用string类型的类型的时候需要进行相关序列化，hash也是要进行相关的系列化，所以会存在很多序列化，在存储的时候hash是可以存储的更加丰富，但是在反序列化的时候，string的反序列化相对较低，而hash的序列化和返序列化是相对hash类更加复杂，所以看业务场景，如果是数据经常修改的那种，为了性能可以使用string，如果是数据不是经常改的那种就可以使用hash，由于hash，存储数据时比较丰富，可以存储多种数据类型

# 持久化



RDB（默认）和AOF

## RDB持久化原理：

通过bgsave命令触发，然后父进程执行fork操作创建子进程，子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换（定时一次性将所有数据进行快照生成一份副本存储在硬盘中）

优点：是一个紧凑压缩的二进制文件，Redis加载RDB恢复数据远远快于AOF的方式。

缺点：由于每次生成RDB开销较大，非实时持久化，

## AOF持久化原理：

开启后，Redis每执行一个修改数据的命令，都会把这个命令添加到AOF文件中。

优点：实时持久化。

缺点：所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积，加载慢

# 数据淘汰策略



# 主从复制

# 集群



# 哨兵







# 原理









# 缓存击穿的解决方案：

原因：就是别人请求数据的时候，很多数据在缓存中无法查询到，直接进入数据查询，

解决方法：

对相关数据进行查询的数据只查询缓存，如果是一些特殊的可以进行数据库查询，也可以采用布隆过滤器进行查询

# 缓存雪崩的解决方案：

原因：一次性加入缓存的数据过多，导致内存过高，从而影响内存的使用导致服务宕机

解决方法：

　　1 redis集群，通过集群方式将数据放置

　　2 后端服务降级和限流：当一个接口请求次数过多，那么就会添加过多数据，可以对服务进行限流，限制访问的数量，这样就可以减少问题的出现

